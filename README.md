## Завдання 1. 
Файл: `task_1.py`<br>
Структури даних. Сортування. Робота з однозв'язним списком

## Завдання 2. 
Файл: `task_2.py`<br>
Рекурсія. Створення фрактала “дерево Піфагора” за допомогою рекурсії

## Завдання 3. 
Файл: `task_3.py`<br>
Дерева, алгоритм Дейкстри

## Завдання 4. 
Файл: `task_4.py`<br>
### Аналіз коду
**Цей код створює і візуалізує бінарне дерево за допомогою бібліотеки `networkx та matplotlib`, що допомагає візуально зрозуміти структуру дерева та його вузли.**

### Клас Node:

Визначає клас Node, який представляє вузол у бінарному дереві.

Кожен вузол має три атрибути:
- **left:** посилання на лівого нащадка.
- **right:** посилання на правого нащадка.
- **val:** значення, яке зберігається в вузлі.
- **color:** додатковий аргумент, що визначає колір вузла.
- **id:** унікальний ідентифікатор, що генерується за допомогою бібліотеки uuid, для ідентифікації кожного вузла.

#### Функція add_edges:

Додає зв'язки між вузлами дерева у граф networkx.

Рекурсивно викликається для кожного вузла та його нащадків.
При цьому, враховуються координати (x, y) вузлів для правильного розташування на графі.

#### Функція draw_tree:

Створює граф `networkx.DiGraph` та визначає початкові позиції для вузлів дерева.<br>
Викликає `add_edges` для додавання зв'язків між вузлами.
Визначає кольори та мітки для вузлів.<br>
Використовує `matplotlib` для візуалізації графа.

#### Створення та відображення дерева:

Створюється бінарне дерево з декількома вузлами.<br>
Викликається функція draw_tree для візуалізації дерева.<br>

## Завдання 5. 
Файл: `task_5.py`<br>
Візуалізація обходу бінарного дерева

## Завдання 6. 
Файл: `task_6.py`<br>
Жадібні алгоритми та динамічне програмування

**Жадібний алгоритм:** Вибирає страви на основі максимального співвідношення калорій до вартості, доки не буде вичерпано бюджет. Це швидкий і простий алгоритм, але не завжди дає оптимальне рішення.

**Алгоритм динамічного програмування:** Створює таблицю значень для кожного можливого бюджету і страви, щоб знайти максимальну калорійність. Це точний метод, але вимагає більше часу та пам'яті.